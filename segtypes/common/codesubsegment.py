from dataclasses import dataclass
from typing import List, Optional
import typing
from util import options
from segtypes.common.code import CommonSegCode
from collections import OrderedDict
import re

from segtypes.segment import Segment
from util.compiler import SN64
from util.symbols import Instruction, Symbol
from util import log

import tools.spimdisasm.spimdisasm as spimdisasm

# abstract class for c, asm, data, etc
class CommonSegCodeSubsegment(Segment):
    double_mnemonics = ["ldc1", "sdc1"]
    word_mnemonics = ["addiu", "sw", "lw", "jtbl"]
    float_mnemonics = ["lwc1", "swc1"]
    short_mnemonics = ["addiu", "lh", "sh", "lhu"]
    byte_mnemonics = ["lb", "sb", "lbu"]
    reg_numbers = {
        "$zero": "$0",
        "$at": "$1",
        "$v0": "$2",
        "$v1": "$3",
        "$a0": "$4",
        "$a1": "$5",
        "$a2": "$6",
        "$a3": "$7",
        "$t0": "$8",
        "$t1": "$9",
        "$t2": "$10",
        "$t3": "$11",
        "$t4": "$12",
        "$t5": "$13",
        "$t6": "$14",
        "$t7": "$15",
        "$s0": "$16",
        "$s1": "$17",
        "$s2": "$18",
        "$s3": "$19",
        "$s4": "$20",
        "$s5": "$21",
        "$s6": "$22",
        "$s7": "$23",
        "$t8": "$24",
        "$t9": "$25",
        "$k0": "$26",
        "$k1": "$27",
        "$gp": "$28",
        "$sp": "$sp",
        "$fp": "$30",
        "$ra": "$31",
    }

    @property
    def needs_symbols(self) -> bool:
        return True

    def get_linker_section(self) -> str:
        return ".text"

    @staticmethod
    # def is_nops(insns: List[CsInsn]) -> bool:
    def is_nops(insns: list) -> bool:
        for insn in insns:
            if insn.mnemonic != "nop":
                return False
        return True

    @staticmethod
    def is_branch_insn(mnemonic):
        return (
            mnemonic.startswith("b")
            and not mnemonic.startswith("binsl")
            and not mnemonic == "break"
        ) or mnemonic == "j"

    @staticmethod
    def replace_reg_names(op_str):
        for regname, regnum in CommonSegCodeSubsegment.reg_numbers.items():
            op_str = op_str.replace(regname, regnum)
        return op_str

    def scan_code(self, rom_bytes, is_asm=False):
        self.textSection = spimdisasm.mips.sections.SectionText(self.context, self.vram_start, self.name, rom_bytes[self.rom_start : self.rom_end])
        self.textSection.analyze()
        self.textSection.setCommentOffset(self.rom_start)

        for func in self.textSection.symbolList:
            assert(isinstance(func, spimdisasm.mips.symbols.SymbolFunction))

            self.process_insns(func, self.rom_start, is_asm=is_asm)

        # Process jumptable labels and pass them to pyMipsDisas
        self.gather_jumptable_labels(rom_bytes)
        for jtblLabelVram in self.parent.jtbl_glabels_to_add:
            romAddr = self.ram_to_rom(jtblLabelVram)
            # TODO: what should we do when this is None?
            if romAddr is not None:
                self.context.addJumpTableLabel(jtblLabelVram, f"L{jtblLabelVram:X}_{romAddr:X}", isAutogenerated=True)

    def split_code(self, rom_bytes):
        self.gather_jumptable_labels(rom_bytes)
        return self.add_labels()

    def process_insns(
        self, funcSpimDisasm: spimdisasm.mips.symbols.SymbolFunction, rom_addr: int, is_asm=False
    ):
        assert isinstance(self.parent, CommonSegCode)
        assert funcSpimDisasm.vram is not None
        assert funcSpimDisasm.vramEnd is not None
        self.parent: CommonSegCode = self.parent

        funcSym = self.parent.create_symbol(funcSpimDisasm.vram, type="func")
        funcSym.given_name = funcSpimDisasm.name

        # Gather symbols found by spimdisasm and create those symbols in splat's side
        for referencedVram in funcSpimDisasm.referencedVRams:
            symType = None
            contextSym = self.context.getAnySymbol(referencedVram)
            if contextSym is not None:
                if contextSym.type == spimdisasm.common.SymbolSpecialType.jumptable:
                    symType = "jtbl"
                    self.parent.jumptables[referencedVram] = (funcSpimDisasm.vram, funcSpimDisasm.vramEnd)
                elif contextSym.type == spimdisasm.common.SymbolSpecialType.function:
                    symType = "func"
            self.parent.create_symbol(referencedVram, type=symType, reference=True)

        for labelOffset in funcSpimDisasm.localLabels:
            labelVram = funcSpimDisasm.vram + labelOffset
            label_sym = self.parent.get_symbol(
                labelVram, type="label", reference=True, local_only=True
            )

            if label_sym is not None:
                contextSym = self.context.getGenericLabel(labelVram)
                if contextSym is not None:
                    contextSym.name = label_sym.name
            else:
                self.parent.labels_to_add.add(labelVram)

        # Main loop
        for i, insn in enumerate(funcSpimDisasm.instructions):
            mnemonic = insn.getOpcodeName().lower()
            instrOffset = i*4
            insn_address = funcSym.vram_start + instrOffset

            funcSym.insns.append(Instruction(insn, mnemonic, rom_addr))
            rom_addr += 4

            if mnemonic == "jr":
                # Record potential jtbl jumps
                rs = insn.getRegisterName(insn.rs)
                if rs not in ["$ra", "$31"]:
                    self.parent.jtbl_jumps[insn_address] = rs

            # update pointer accesses from this function
            if instrOffset in funcSpimDisasm.pointersPerInstruction:
                symAddress = funcSpimDisasm.pointersPerInstruction[instrOffset]

                sym = self.parent.create_symbol(
                    symAddress, offsets=True, reference=True
                )

                if mnemonic in self.double_mnemonics + self.word_mnemonics + self.float_mnemonics + self.short_mnemonics + self.byte_mnemonics:
                    self.update_access_mnemonic(sym, mnemonic)


    def update_access_mnemonic(self, sym: Symbol, mnemonic: str):
        if not sym.access_mnemonic:
            sym.access_mnemonic = mnemonic
        elif sym.access_mnemonic == "addiu":
            sym.access_mnemonic = mnemonic
        elif sym.access_mnemonic in self.double_mnemonics:
            return
        elif (
            sym.access_mnemonic in self.float_mnemonics
            and mnemonic in self.double_mnemonics
        ):
            sym.access_mnemonic = mnemonic
        elif sym.access_mnemonic in self.short_mnemonics:
            return
        elif sym.access_mnemonic in self.byte_mnemonics:
            return
        else:
            sym.access_mnemonic = mnemonic

    # Determine symbols
    def determine_symbols(self):
        hi_lo_max_distance = options.hi_lo_max_distance()

        for func_addr in self.funcs:
            func = self.funcs[func_addr]
            func_end_addr = func.insns[-1].instruction.address + 4

            possible_jtbl_jumps = [
                (k, v)
                for k, v in self.parent.jtbl_jumps.items()
                if k >= func_addr and k < func_end_addr
            ]
            possible_jtbl_jumps.sort(key=lambda x: x[0])

            for i in range(len(func.insns)):
                # hi_insn: CsInsn = func.insns[i].instruction
                hi_insn = func.insns[i].instruction

                # Ensure the first item in the list is always ahead of where we're looking
                while (
                    len(possible_jtbl_jumps) > 0
                    and possible_jtbl_jumps[0][0] < hi_insn.address
                ):
                    del possible_jtbl_jumps[0]

                # Find gp relative reads and writes e.g  lw $a1, 0x670($gp)
                if hi_insn.op_str.endswith("($gp)"):
                    gp_base = options.get_gp()
                    if gp_base is None:
                        log.error(
                            "gp_value not set in yaml, can't calculate %gp_rel reloc value for "
                            + hi_insn.op_str
                        )

                    op_split = hi_insn.op_str.split(", ")
                    gp_offset = op_split[1][:-5]  # extract the 0x670 part
                    if len(gp_offset) == 0:
                        gp_offset = 0
                    else:
                        gp_offset = int(gp_offset, 16)
                    symbol_addr = gp_base + gp_offset

                    sym = self.parent.create_symbol(
                        symbol_addr, offsets=True, reference=True
                    )
                    offset = symbol_addr - sym.vram_start
                    offset_str = f"+0x{offset:X}"

                    if self.parent:
                        self.parent.check_rodata_sym(func_addr, sym)

                    self.update_access_mnemonic(sym, hi_insn.mnemonic)

                    func.insns[i].is_gp = True
                    func.insns[i].hi_lo_sym = sym
                    func.insns[i].sym_offset_str = offset_str
                # All hi/lo pairs start with a lui
                elif hi_insn.mnemonic == "lui":
                    op_split = hi_insn.op_str.split(", ")
                    hi_reg = op_split[0]

                    if not op_split[1].startswith("0x"):
                        continue

                    lui_val = int(op_split[1], 0)

                    # Assumes all luis are going to load from 0x80000000 or higher (maybe false)
                    if lui_val >= 0x8000:
                        # Iterate over the next few instructions to see if we can find a matching lo
                        for j in range(
                            i + 1, min(i + hi_lo_max_distance, len(func.insns))
                        ):
                            lo_insn = func.insns[j].instruction

                            s_op_split = lo_insn.op_str.split(", ")

                            if lo_insn.mnemonic == "lui" and hi_reg == s_op_split[0]:
                                break

                            if lo_insn.mnemonic in ["addiu", "ori"]:
                                lo_reg = s_op_split[-2]
                            else:
                                lo_reg = s_op_split[-1][
                                    s_op_split[-1].rfind("(") + 1 : -1
                                ]

                            if hi_reg == lo_reg:
                                if lo_insn.mnemonic not in [
                                    "addiu",
                                    "lw",
                                    "sw",
                                    "lh",
                                    "sh",
                                    "lhu",
                                    "lb",
                                    "sb",
                                    "lbu",
                                    "lwc1",
                                    "swc1",
                                    "ldc1",
                                    "sdc1",
                                ]:
                                    break

                                # Match!
                                reg_ext = ""

                                # I forgot what this is doing
                                junk_search = re.search(r"[\(]", s_op_split[-1])
                                if junk_search is not None:
                                    if junk_search.start() == 0:
                                        break
                                    s_str = s_op_split[-1][: junk_search.start()]
                                    reg_ext = s_op_split[-1][junk_search.start() :]
                                else:
                                    s_str = s_op_split[-1]

                                if options.get_compiler() == SN64:
                                    reg_ext = CommonSegCodeSubsegment.replace_reg_names(
                                        reg_ext
                                    )

                                symbol_addr = (lui_val * 0x10000) + int(s_str, 0)

                                sym: Optional[Symbol] = None
                                offset_str = ""

                                # If the symbol is likely in the rodata section
                                if (
                                    not self.parent.text_follows_rodata
                                    and symbol_addr > func_addr
                                ) or (
                                    self.parent.text_follows_rodata
                                    and symbol_addr < func_addr
                                ):
                                    # Sanity check that the symbol is within this segment's vram
                                    if (
                                        self.parent.vram_end
                                        and symbol_addr < self.parent.vram_end
                                    ):
                                        # If we've seen possible jumps to a jumptable and this symbol isn't too close to the end of the function
                                        if (
                                            len(possible_jtbl_jumps) > 0
                                            and func_end_addr - lo_insn.address >= 0x30
                                        ):
                                            for jump in possible_jtbl_jumps:
                                                if jump[1] == s_op_split[0]:
                                                    dist_to_jump = (
                                                        possible_jtbl_jumps[0][0]
                                                        - lo_insn.address
                                                    )
                                                    if dist_to_jump <= 16:
                                                        sym = self.parent.create_symbol(
                                                            symbol_addr,
                                                            reference=True,
                                                            type="jtbl",
                                                            local_only=True,
                                                        )

                                                        self.parent.jumptables[
                                                            symbol_addr
                                                        ] = (func_addr, func_end_addr)
                                                        break

                                if not sym:
                                    sym = self.parent.create_symbol(
                                        symbol_addr, offsets=True, reference=True
                                    )
                                    offset = symbol_addr - sym.vram_start
                                    if offset != 0:
                                        offset_str = f"+0x{offset:X}"

                                if self.parent:
                                    self.parent.check_rodata_sym(func_addr, sym)

                                self.update_access_mnemonic(sym, lo_insn.mnemonic)

                                func.insns[i].is_hi = True
                                func.insns[i].hi_lo_sym = sym
                                func.insns[i].sym_offset_str = offset_str

                                func.insns[j].is_lo = True
                                func.insns[j].hi_lo_sym = sym
                                func.insns[j].sym_offset_str = offset_str
                                func.insns[j].hi_lo_reg = reg_ext
                                break

    def add_labels(self):
        ret = {}

        function_macro = options.get_asm_function_macro()
        data_macro = options.get_asm_data_macro()

        for func_addr in self.funcs:
            func_text = []
            func = self.funcs[func_addr]

            # Add function label
            func_text.append(f"{function_macro} {func.name}")

            if options.get_compiler() == SN64:
                func_text.append(f".ent {func.name}")
                func_text.append(f"{func.name}:")

            indent_next = False

            mnemonic_ljust = options.mnemonic_ljust()
            rom_addr_padding = options.rom_address_padding()

            for insn in func.insns:
                insn_addr = insn.instruction.address
                # Add a label if we need one
                if insn_addr in self.parent.jtbl_glabels_to_add:
                    func_text.append(f"{data_macro} L{insn_addr:X}_{insn.rom_addr:X}")
                elif insn_addr in self.parent.labels_to_add:
                    self.parent.labels_to_add.remove(insn_addr)
                    func_text.append(".L{:X}:".format(insn_addr))

                if rom_addr_padding:
                    rom_str = "{0:0{1}X}".format(insn.rom_addr, rom_addr_padding)
                else:
                    rom_str = "{:X}".format(insn.rom_addr)

                if options.get_compiler() == SN64:
                    asm_comment = ""
                else:
                    asm_comment = "/* {} {:X} {} */".format(
                        rom_str, insn_addr, insn.instruction.bytes.hex().upper()
                    )

                if insn.is_hi:
                    assert insn.hi_lo_sym
                    op_str = ", ".join(
                        insn.op_str.split(", ")[:-1]
                        + [f"%hi({insn.hi_lo_sym.name}{insn.sym_offset_str})"]
                    )
                elif insn.is_lo:
                    assert insn.hi_lo_sym
                    op_str = ", ".join(
                        insn.op_str.split(", ")[:-1]
                        + [
                            f"%lo({insn.hi_lo_sym.name}{insn.sym_offset_str}){insn.hi_lo_reg}"
                        ]
                    )
                elif insn.is_gp:
                    op_str = ", ".join(
                        insn.op_str.split(", ")[:-1]
                        + [f"%gp_rel({insn.hi_lo_sym.name}{insn.sym_offset_str})($gp)"]
                    )
                else:
                    op_str = insn.op_str

                if self.is_branch_insn(insn.instruction.mnemonic):
                    branch_addr = int(insn.instruction.op_str.split(",")[-1].strip(), 0)
                    if branch_addr in self.parent.jtbl_glabels_to_add:
                        label_str = f"L{branch_addr:X}_{self.ram_to_rom(branch_addr):X}"
                        op_str = ", ".join(insn.op_str.split(", ")[:-1] + [label_str])

                insn_text = insn.mnemonic
                if indent_next:
                    indent_next = False
                    insn_text = " " + insn_text

                asm_insn_text = "  {}{}".format(
                    insn_text.ljust(mnemonic_ljust), op_str
                ).rstrip()

                func_text.append(asm_comment + asm_insn_text)

                if (
                    insn.instruction.mnemonic != "branch"
                    and insn.instruction.mnemonic.startswith("b")
                    or insn.instruction.mnemonic.startswith("j")
                ):
                    indent_next = True

            end_label = options.get_asm_end_label()

            if end_label:
                func_text.append(f"{end_label} {func.name}")

            ret[func_addr] = (func_text, func.rom)

            if options.find_file_boundaries():
                # If this is not the last function in the file
                if func_addr != list(self.funcs.keys())[-1]:

                    # Find where the function returns
                    jr_pos: Optional[int] = None
                    for i, insn in enumerate(reversed(func.insns)):
                        if (
                            insn.instruction.mnemonic == "jr"
                            and insn.instruction.op_str in ["$ra", "$31"]
                        ):
                            jr_pos = i
                            break

                    # If there is more than 1 nop after the return
                    if (
                        jr_pos is not None
                        and jr_pos > 1
                        and self.is_nops(
                            [insn.instruction for insn in func.insns[-jr_pos + 1 :]]
                        )
                    ):
                        new_file_addr = func.insns[-1].rom_addr + 4
                        if (new_file_addr % 16) == 0:
                            if not self.parent.reported_file_split:
                                self.parent.reported_file_split = True
                                print(
                                    f"Segment {self.name}, function at vram {func_addr:X} ends with extra nops, indicating a likely file split."
                                )
                                print(
                                    "File split suggestions for this segment will follow in config yaml format:"
                                )
                            print(f"      - [0x{new_file_addr:X}, asm]")

        return ret

    def gather_jumptable_labels(self, rom_bytes):
        # TODO: use the seg_symbols for this
        # jumptables = [j.type == "jtbl" for j in self.seg_symbols]
        for jumptable in self.parent.jumptables:
            start, end = self.parent.jumptables[jumptable]
            rom_offset = self.rom_start + jumptable - self.vram_start

            if rom_offset <= 0:
                return

            while rom_offset:
                word = rom_bytes[rom_offset : rom_offset + 4]
                word_int = int.from_bytes(word, options.get_endianess())
                if word_int >= start and word_int <= end:
                    self.parent.jtbl_glabels_to_add.add(word_int)
                else:
                    break

                rom_offset += 4

    def should_scan(self) -> bool:
        return (
            options.mode_active("code")
            and self.rom_start != "auto"
            and self.rom_end != "auto"
        )

    def should_split(self) -> bool:
        return self.extract and options.mode_active("code")
